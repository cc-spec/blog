(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{501:function(t,e,v){"use strict";v.r(e);var a=v(25),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("vue 特性")]),t._v(" "),v("ul",[v("li",[t._v("响应式数据：主动推数据变化")]),t._v(" "),v("li",[t._v("虚拟DOM：被动计算数据的diff")]),t._v(" "),v("li",[t._v("组件级别划分：组件之间的变化，通过响应式来通知更新，组件内部的变化通过虚拟dom更新")])]),t._v(" "),v("h2",{attrs:{id:"_1-框架对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-框架对比"}},[t._v("#")]),t._v(" 1. 框架对比")]),t._v(" "),v("ul",[v("li",[t._v("vue与react\n"),v("ul",[v("li",[t._v("vue2\n"),v("ul",[v("li",[t._v("数据响应：数据发生变化了，会主动通知修改了哪些数据")]),t._v(" "),v("li",[t._v("模板书写：template")])])]),t._v(" "),v("li",[t._v("react\n"),v("ul",[v("li",[t._v("数据响应：数据发生变化，只能通过新老数据的计算diff来得知数据的变化")]),t._v(" "),v("li",[t._v("模板书写：JSX")])])])])]),t._v(" "),v("li",[t._v("vue与angular\n"),v("ul",[v("li",[t._v("angular使用TypeScript开发")]),t._v(" "),v("li",[t._v("Vue体积较angular小")]),t._v(" "),v("li",[t._v("angular中的API接口较多，学习成本大，更适合于大型应用")]),t._v(" "),v("li",[t._v("Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少")])])])]),t._v(" "),v("h2",{attrs:{id:"_2-vue生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue生命周期"}},[t._v("#")]),t._v(" 2. "),v("RouterLink",{attrs:{to:"/vue/生命周期.html"}},[t._v("Vue生命周期")])],1),t._v(" "),v("h2",{attrs:{id:"_3-vue-router"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue-router"}},[t._v("#")]),t._v(" 3. "),v("RouterLink",{attrs:{to:"/vue/vue Router.html"}},[t._v("Vue Router")])],1),t._v(" "),v("h2",{attrs:{id:"_4-vuex"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-vuex"}},[t._v("#")]),t._v(" 4. "),v("RouterLink",{attrs:{to:"/vue/vuex.html"}},[t._v("Vuex")])],1),t._v(" "),v("h2",{attrs:{id:"_5-组件间通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-组件间通信"}},[t._v("#")]),t._v(" 5. "),v("RouterLink",{attrs:{to:"/vue/组件间通信.html"}},[t._v("组件间通信")])],1),t._v(" "),v("h2",{attrs:{id:"_6-vue数据绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue数据绑定"}},[t._v("#")]),t._v(" 6. "),v("RouterLink",{attrs:{to:"/vue/数据双向绑定原理.html"}},[t._v("Vue数据绑定")])],1),t._v(" "),v("h2",{attrs:{id:"_7-计算属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-计算属性"}},[t._v("#")]),t._v(" 7. 计算属性")]),t._v(" "),v("ul",[v("li",[t._v("计算属性存在缓存，即上一次调用计算属性的getter方法后的数据，缓存发生变化才会重新求值；")]),t._v(" "),v("li",[t._v("方法：一旦重新渲染就会立即执行这个函数")])])])}),[],!1,null,null,null);e.default=_.exports}}]);