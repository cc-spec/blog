---
title: 图解HTTP
author: coderc
date: 2022-01-04 14:47:51
permalink: /pages/12e88f/
categories:
  - reading
tags:
  - 
---
## 一、TCP/IP协议族
### 1. 协议
- 规则，规定了从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤等。
### 2. TCP/IP协议
- 与互联网相关的协议的集合。
![TCP/IP协议族](./TCPIP.png)
### 3. TCP/IP协议的分层管理
- #### 应用层
   - 决定了向用户提供服务时通信的活动。
   - 包含**FTP**(File Transfer Protocol，文本传输协议)，**DNS**(Domain Name System，域名系统)，**HTTP**(HyperText Transfer Protocol，超文本传输协议)。
- #### 传输层
   - 对应用层提供网络连接中的两台计算机之间的数据传输。
   - 包含**TCP**(Transmission Control Protocol，传输控制协议)，**UDP**(User Data Protocol，用户数据报协议)。
- #### 网络层(网络互连层)
   - 处理在网络上流动的数据包，规定通过怎样的传输路线到达对方计算机。
   - 包含**IP**(Internet Protocol，网际协议)。
- #### 链路层(数据链路层，网络接口层)
   - 处理连接网络的硬件部分。
   - 包括控制操作系统、硬件的设备驱动、NFC，光纤等物理可见设备。
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fe23f9c268d48e7a40c06417b6183c3~tplv-k3u1fbpfcp-zoom-1.image)
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8d37803e33847c3a08e1a5b58541f2a~tplv-k3u1fbpfcp-zoom-1.image)
### 4. 与HTTP相关的协议：IP、TCP、DNS
- #### IP协议
   - 处于网络层，作用是把各种数据包传递给对方，并确定传送成功。
   - 保证成功传送的重要的两个条件：IP地址和MAC地址(Media Access Control Address)。
   - 通常通信的双方不在一个局域网内,需要通过多台计算机和网络设备进行中转才可实现连接,进行中转时, 会利用下一台中转设备的MAC地址来搜索下一个中转目标，设备使用ARP协议(Address Resolution Protocol)解析IP地址反查出对应的MAC地址
- #### TCP协议
   - TCP协议处于传输层, 提供可靠的字节流服务.
   - **TCP三次握手建立连接**   
   **第一次握手**: 发送端发送一个带有**SYN**(synchronize, 同步处理标志)的数据包到接收端.  
   **第二次握手**: 接收端收到数据包后, 回传一个带有**ACK**(acknowledgement, 确认标志)的数据包, 表示确认收到发送端第一次握手时发送的数据包.  
   **第三次握手**: 发送端再回传一个带有ACK标志的数据包, 表示握手结束.
   - **TCP四次挥手断开连接**  
	**第一次挥手**：接收端发送一个FIN(finish结束标志)，用来关闭发送端与接收端的数据传送。  
	**第二次挥手**：发送端收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。  
	 **第三次挥手**：发送端关闭与接收端的连接，发送一个FIN给接收端。  
	 **第四次挥手**：接收端发回ACK报文确认，并将确认序号设置为收到序号加1。
- #### DNS服务
   - 提供域名到IP地址之间的解析作用
### 5. **输入一个URL到生成页面经历了什么**
> 1. **DNS 解析:将域名解析成 IP 地址**
> 2. **TCP 连接：TCP 三次握手之后确定可以进行数据的传输**  
   2.1 第一次握手: 客户端发送一个带有SYN(synchronize, 同步处理标志)的数据包到服务器端.  
   2.2 第二次握手: 服务器端收到数据包后, 回传一个带有ACK(acknowledgement, 确认标志)的数据包, 表示确认收到客户端第一次握手时发送的数据包.  
   2.3 第三次握手: 客户端再回传一个带有ACK标志的数据包, 表示握手结束.
> 3. **客户端发送 HTTP 请求(对应前端)：构建HTTP请求报文并通过TCP协议发送到服务器指定端口**
> 4. **服务器端处理请求并返回 HTTP 报文(对应后端)：在固定的端口接收到TCP报文后，对HTTP协议进行解析，按照报文格式进一步封装成HTTP Request对象**
> 5. **浏览器解析报文渲染页面**  
   5.1 解析HTML文件生成DOM树  
   5.2 解析CSS文件生成CSSOM（CSS Object Model）  
   5.3 将DOM树和CSS渲染树合并成一个渲染树  
   5.4 根据渲染树来布局（layout），计算每个节点的几何信息  
   5.5 将各个节点绘制（paint）在屏幕上  
> 6. **断开连接：TCP 四次挥手**  
   6.1 第一次挥手：客户端发送一个FIN(finish结束标志)，用来关闭客户端与服务器端的数据传送。  
   6.2 第二次挥手：服务器端收到这个FIN，发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。  
   6.3 第三次挥手：服务器端关闭与客户端的连接，发送一个FIN给客户端。   
   6.4 第四次挥手：客户端发回ACK报文确认，并将确认序号设置为收到序号加1。  
## 二. HTTP协议
> 用于HTTP协议交互的信息被称为HTTP报文，客户端发送的叫做请求报文；服务器端发送的叫做响应报文
> 报文基本由**报文首部+报文主体**两部分构成
### 1. 请求报文
- 构成：请求方法, 请求URI, 协议版本, 可选的请求首部字段, 内容实体
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c6369ffc12d46319b2beeeb280c9b45~tplv-k3u1fbpfcp-zoom-1.image)
- 请求方法  

|方法|说明|支持的HTTP协议版本|
|:-:|:-:|:-:|
|GET|获取资源|1.0、1.1|
|POST|传输实体主体|1.0、1.1|
|PUT|传输文件|1.0、1.1|
|HEAD|获得报文首部|1.0、1.1|
|DELETE|删除文件|1.0、1.1|
|OPTIONS|询问支持的方法|1.1|
|TRACK|追踪路径|1.1|
|CONNECT|要求用隧道协议连接代理|1.1|
|LINK|建立和资源之间的联系|1.0|
|UNLINK|断开连接关系|1.0|
- 请求首部

|名称|内容|
|:-:|:-:|
|请求行|请求方法、请求URI、HTTP版本|
|请求首部字段||
|通用首部字段||
|实体首部字段||
|其他||
### 2. 响应报文
- 构成：协议版本, 状态码, 状态码的解释说明文字, 可选的响应首部字段, 实体主体构成
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7e0bb210a324e39aeefb1996901c3d8~tplv-k3u1fbpfcp-zoom-1.image)
- 状态码：反馈从服务器端返回的请求结果 
   - 概述

   ||类别|原因短语|
   |:-:|:-:|:-:|
   |1XX|Informational(信息性状态码)|接收的请求正在处理|
   |2XX|Success(成功状态码)|请求正常处理完毕|
   |3XX|Redirection(重定向状态码)|需要进行附加操作以完成请求|
   |4XX|Client Error(客户端错误状态码)|服务器无法处理请求|
   |5XX|Server Error(服务器端错误状态码)|服务器处理请求出错|
   - 详细  
   ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a8730f4a4324346a03562bc4bebd7ca~tplv-k3u1fbpfcp-zoom-1.image)
- 响应首部

|名称|内容|
|:-:|:-:|
|状态行|状态码、原因短语、HTTP版本|
|响应首部字段||
|通用首部字段||
|实体首部字段||
|其他||
### 3. Cookie
`首部：Set-Cookie`
- HTTP是无状态协议, 不对之前发生过的请求和响应的状态进行管理, 无法保存用户的登录信息, Cookie技术通过在请求和响应报文中添加Cookie信息来控制客户端的状态.
- Cookie的添加过程
   - 无Cookie时
      - (1). 客户端发送请求
      - (2). 服务器端在响应中添加Cookie后发送响应
   - 有Cookie时
      - (3). 客户端在请求中添加Cookie后发送请求
      - (4). 服务器端检查Cookie是否是是刚才发的那个，并且发送响应